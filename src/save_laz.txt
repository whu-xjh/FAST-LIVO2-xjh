#include <LASlib/laszip.hpp>
#include <laszip_api.h>
#include <pcl/point_types.h>

template<typename PointT>
void LIVMapper::saveAsLAZ(const std::string& filename, const pcl::PointCloud<PointT>& cloud)
{
  if (filename.empty() || filename.find_last_of(".") < 0)
  {
    std::cerr << "Error: invalid LAZ filename" << std::endl;
    return;
  }
  
  // 初始化LASzip写入器
  laszip_POINTER laszip_writer;
  if (laszip_create(&laszip_writer))
  {
    std::cerr << "Error: creating LASzip writer failed" << std::endl;
    return;
  }
  
  // 初始化头信息
  laszip_header* header;
  if (laszip_get_header_pointer(laszip_writer, &header))
  {
    std::cerr << "Error: getting LASzip header failed" << std::endl;
    laszip_destroy(laszip_writer);
    return;
  }
  
  // 设置LAS参数
  header->version_major = 1;
  header->version_minor = 2;
  header->point_data_format = 2; // XYZ + Intensity + RGB + GPS time
  header->point_data_record_length = 26;
  header->number_of_point_records = cloud.points.size();
  header->x_scale_factor = 0.0001;
  header->y_scale_factor = 0.0001;
  header->z_scale_factor = 0.0001;
  header->x_offset = 0.0;
  header->y_offset = 0.0;
  header->z_offset = 0.0;
  
  // // 计算边界框
  // double min_x = std::numeric_limits<double>::max();
  // double max_x = std::numeric_limits<double>::lowest();
  // double min_y = min_x, max_y = max_x;
  // double min_z = min_x, max_z = max_x;

  // Set bounding box
  if (!cloud.points.empty())
  {
    // 打开LAZ文件
    laszip_BOOL compress = 1;  // 启用压缩
    if (laszip_open_writer(laszip_writer, filename.c_str(), compress) != 0) {
        laszip_CHAR* error;
        laszip_get_error(laszip_writer, &error);
        std::cerr << "Error opening LAZ file: " << error << std::endl;
        laszip_destroy(laszip_writer);
        return;
    }
    
    // 获取点指针
    laszip_point* laz_point;
    if (laszip_get_point_pointer(laszip_writer, &laz_point) != 0) {
        std::cerr << "Error getting point pointer" << std::endl;
        laszip_close_writer(laszip_writer);
        laszip_destroy(laszip_writer);
        return;
    }

    for (const auto& point : cloud.points)
    {
      // min_x = std::min(min_x, point.x());
      // min_y = std::min(min_y, point.y());
      // min_z = std::min(min_z, point.z());
      // max_x = std::max(max_x, point.x());
      // max_y = std::max(max_y, point.y());
      // max_z = std::max(max_z, point.z());

      laz_point->X = static_cast<I32>((point.x - header->x_offset) / header->x_scale_factor);
      laz_point->Y = static_cast<I32>((point.y - header->y_offset) / header->y_scale_factor);
      laz_point->Z = static_cast<I32>((point.z - header->z_offset) / header->z_scale_factor);

      // Set intensity if available
      if constexpr (std::is_same_v<PointT, pcl::PointXYZI>) {
        laz_point->intensity = static_cast<U16>(point.intensity);
      }
      else if constexpr (std::is_same_v<PointT, pcl::PointXYZINormal>) {
        laz_point->intensity = static_cast<U16>(point.intensity);
      }
      else if constexpr (std::is_same_v<PointT, pcl::PointXYZRGB>) {
        laz_point->rgb[0] = point.r;
        laz_point->rgb[1] = point.g;
        laz_point->rgb[2] = point.b;
      }

      // Write point
      laszip_write_point(laszip_writer);
    }
    
    // Close writer
    laszip_close_writer(laszip_writer);
  }
  
  // Always destroy the writer
  laszip_destroy(laszip_writer);
  
  std::cout << GREEN << "Point cloud saved as LAZ: " << filename 
            << " with " << cloud.points.size() << " points" << RESET << std::endl;
}

// Explicit template instantiation
template void LIVMapper::saveAsLAZ<pcl::PointXYZRGB>(const std::string& filename, const pcl::PointCloud<pcl::PointXYZRGB>& cloud);
template void LIVMapper::saveAsLAZ<pcl::PointXYZI>(const std::string& filename, const pcl::PointCloud<pcl::PointXYZI>& cloud);
template void LIVMapper::saveAsLAZ<pcl::PointXYZINormal>(const std::string& filename, const pcl::PointCloud<pcl::PointXYZINormal>& cloud);